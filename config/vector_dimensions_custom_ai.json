[
  {
    "id": "num_objects",
    "name_ja": "オブジェクト総数",
    "description": "画像内に存在する孤立した図形の総数。",
    "algorithm_idea": "1. 画像をグレースケールに変換し、cv2.thresholdで二値化する。 2. cv2.findContoursで輪郭を検出する。 3. 検出された輪郭の数を数える。 4. その数を、想定される最大オブジェクト数（例: 20）で割り、結果が1.0を超える場合は1.0とする。オブジェクトが検出されない場合は0.0とする。"
  },
  {
    "id": "proportion_of_circles",
    "name_ja": "円形オブジェクト比率",
    "description": "画像内のオブジェクトのうち、円形に近い形状の割合。",
    "algorithm_idea": "1. 輪郭を検出する。 2. 各輪郭について、その面積と、輪郭を囲む最小外接円の面積（cv2.minEnclosingCircleで得られる円の半径から計算）を計算する。 3. (輪郭面積 / 最小外接円面積) が0.85以上のものを円とみなす。 4. 円とみなされた輪郭の数を総輪郭数で割り、正規化する。総輪郭数が0の場合は0.0とする。"
  },
  {
    "id": "proportion_of_rectangles",
    "name_ja": "四角形オブジェクト比率",
    "description": "画像内のオブジェクトのうち、四角形に近い形状の割合。",
    "algorithm_idea": "1. 輪郭を検出する。 2. 各輪郭について、cv2.approxPolyDPで近似多角形を計算する（εは輪郭の周長の数%）。 3. 近似多角形の頂点数が4であり、かつcv2.minAreaRectで得られる回転矩形と輪郭の面積比が0.95以上のものを四角形とみなす。 4. 四角形とみなされた輪郭の数を総輪郭数で割り、正規化する。総輪郭数が0の場合は0.0とする。"
  },
  {
    "id": "average_object_area_ratio",
    "name_ja": "平均オブジェクト面積比",
    "description": "各オブジェクトの平均的な面積が、画像全体の面積に対してどの程度の割合か。",
    "algorithm_idea": "1. 輪郭を検出する。 2. 各輪郭の面積を計算し、それらの平均値を求める。 3. 平均面積を画像全体のピクセル数（幅 * 高さ）で割り、正規化する。オブジェクトが検出されない場合は0.0とする。"
  },
  {
    "id": "image_brightness",
    "name_ja": "画像の平均明度",
    "description": "画像全体の明るさの度合い。",
    "algorithm_idea": "1. 画像をcv2.cvtColorでBGRからHSV色空間に変換する。 2. V（明度）チャンネルの平均値を計算する。 3. 平均値を255.0で割って正規化する。"
  },
  {
    "id": "image_saturation",
    "name_ja": "画像の平均彩度",
    "description": "画像全体の色鮮やかさの度合い。",
    "algorithm_idea": "1. 画像をcv2.cvtColorでBGRからHSV色空間に変換する。 2. S（彩度）チャンネルの平均値を計算する。 3. 平均値を255.0で割って正規化する。"
  },
  {
    "id": "dominant_hue",
    "name_ja": "主要色相",
    "description": "画像内で最も頻繁に出現する色相（円環状の色合い）。",
    "algorithm_idea": "1. 画像をcv2.cvtColorでBGRからHSV色空間に変換する。 2. H（色相）チャンネルのヒストグラムを計算する（0-179の範囲）。 3. ヒストグラムのピークとなる色相値を特定する。 4. その色相値を179.0で割って正規化する。色情報がない場合は0.0とする。"
  },
  {
    "id": "spatial_spread",
    "name_ja": "オブジェクトの空間的広がり",
    "description": "全てのオブジェクトを包含する最小の矩形が、画像全体に占める割合。",
    "algorithm_idea": "1. 輪郭を検出する。 2. 検出された全ての輪郭を結合し、それらを囲むcv2.boundingRectで最小の外接矩形を計算する。 3. その矩形の面積を画像全体の面積（幅 * 高さ）で割り、正規化する。オブジェクトが検出されない場合は0.0とする。"
  },
  {
    "id": "horizontal_balance",
    "name_ja": "水平方向の重心偏り",
    "description": "画像内のオブジェクトの重心が、水平方向の中心からどれだけ偏っているか。",
    "algorithm_idea": "1. 輪郭を検出し、cv2.momentsから各輪郭の重心(cx, cy)を計算する。 2. 全オブジェクトのX座標の加重平均を計算する（面積で重み付け）。 3. 画像の幅の中央 (width / 2.0) からのずれの絶対値を計算する。 4. そのずれを (画像の幅 / 2.0) で割って正規化する。0.0が中央に位置、1.0が端に位置を示す。オブジェクトが検出されない場合は0.0とする。"
  },
  {
    "id": "vertical_balance",
    "name_ja": "垂直方向の重心偏り",
    "description": "画像内のオブジェクトの重心が、垂直方向の中心からどれだけ偏っているか。",
    "algorithm_idea": "1. 上記と同様にY座標について計算する。画像の高さの中央 (height / 2.0) からのずれの絶対値を計算し、それを (画像の高さ / 2.0) で割って正規化する。オブジェクトが検出されない場合は0.0とする。"
  },
  {
    "id": "edge_density",
    "name_ja": "エッジ密度",
    "description": "画像内のエッジピクセルの総量。画像の複雑さや詳細度を表す。",
    "algorithm_idea": "1. 画像をグレースケールに変換する。 2. cv2.Cannyでエッジ検出を適用する。 3. 検出されたエッジピクセル（値が255）の数を数える。 4. その数を画像全体のピクセル数（幅 * 高さ）で割って正規化する。"
  },
  {
    "id": "color_variety",
    "name_ja": "色の多様性",
    "description": "画像内に存在する色の種類の多さ。",
    "algorithm_idea": "1. 画像をcv2.cvtColorでBGRからHSV色空間に変換する。 2. HとSチャンネルの値をそれぞれ適度に量子化（例: Hを10段階、Sを5段階）し、各ピクセルを量子化された(H, S)のペアで分類する。 3. 画像内に存在するユニークな(H, S)ペアの数を数える。 4. その数を、量子化によって可能な最大ユニーク色の数（10 * 5 = 50）で割って正規化する。色情報がない場合は0.0とする。"
  },
  {
    "id": "overlap_ratio",
    "name_ja": "オブジェクトの重なり比率",
    "description": "オブジェクト同士がどれだけ重なっているか。",
    "algorithm_idea": "1. 輪郭を検出し、各輪郭を個別の二値マスクにcv2.drawContoursで塗りつぶす。 2. 全てのマスクを足し合わせ、ピクセル値が1を超える部分（重なり領域）のピクセル数を数える。 3. 重なり領域のピクセル数を、全てのオブジェクトの面積の合計（各マスクのピクセル数の合計）で割り、正規化する。オブジェクトが1つ以下の場合や重なりがない場合は0.0とする。"
  },
  {
    "id": "object_size_variance",
    "name_ja": "オブジェクトサイズのばらつき",
    "description": "オブジェクトの面積がどれだけ均一でないか。",
    "algorithm_idea": "1. 輪郭を検出し、各輪郭の面積を計算する。 2. 面積の配列の標準偏差を計算する。 3. 標準偏差を、最大オブジェクト面積（もしくは全オブジェクトの平均面積）で割って正規化する。オブジェクトが1つ以下の場合や全てのオブジェクトの面積が0の場合は0.0とする。"
  },
  {
    "id": "symmetry_horizontal",
    "name_ja": "水平対称性",
    "description": "画像が水平中心線に対してどれだけ対称的か。",
    "algorithm_idea": "1. 画像をグレースケールに変換し、cv2.thresholdで二値化する。 2. 画像を水平方向で半分に分割し、片方の半分（例: 上半分）をcv2.flipで垂直方向に反転させる。 3. 反転した半分と残りの半分（例: 下半分）のピクセルごとの絶対差の平均値を計算する。 4. その差の平均値を255.0で割った値を1.0から引くことで、対称性が高いほど1.0に近づくように正規化する。画像が非常に小さい場合は0.0とする。"
  },
  {
    "id": "symmetry_vertical",
    "name_ja": "垂直対称性",
    "description": "画像が垂直中心線に対してどれだけ対称的か。",
    "algorithm_idea": "1. 画像をグレースケールに変換し、cv2.thresholdで二値化する。 2. 画像を垂直方向で半分に分割し、片方の半分（例: 左半分）をcv2.flipで水平方向に反転させる。 3. 反転した半分と残りの半分（例: 右半分）のピクセルごとの絶対差の平均値を計算する。 4. その差の平均値を255.0で割った値を1.0から引くことで、対称性が高いほど1.0に近づくように正規化する。画像が非常に小さい場合は0.0とする。"
  },
  {
    "id": "aspect_ratio_mean",
    "name_ja": "平均アスペクト比",
    "description": "オブジェクトの平均的な縦横比。正方形に近いほど1.0に近づく。",
    "algorithm_idea": "1. 輪郭を検出する。 2. 各輪郭について、cv2.minAreaRectで最小外接矩形を取得し、その幅と高さを計算する。 3. 各オブジェクトのアスペクト比を `min(width, height) / max(width, height)` として計算する（これにより0.0〜1.0に正規化される）。 4. 全オブジェクトのアスペクト比の平均を計算する。オブジェクトが検出されない場合は0.0とする。"
  },
  {
    "id": "convexity_mean",
    "name_ja": "平均凸性",
    "description": "オブジェクトがどれだけ凸形状に近いか（凹みがないか）の平均。",
    "algorithm_idea": "1. 輪郭を検出する。 2. 各輪郭について、cv2.convexHullで凸包を計算する。 3. 輪郭の面積を計算し、凸包の面積も計算する。 4. 各オブジェクトの凸性を `(輪郭面積 / 凸包面積)` として計算する（この値は0.0〜1.0）。 5. 全てのオブジェクトの凸性の平均を計算する。オブジェクトが検出されない場合は0.0とする。"
  },
  {
    "id": "orientation_variance",
    "name_ja": "オブジェクトの方向ばらつき",
    "description": "各オブジェクトの主要な方向（傾き）がどれだけばらついているか。",
    "algorithm_idea": "1. 輪郭を検出する。 2. 各輪郭について、cv2.minAreaRectで最小外接矩形を取得し、その回転角度を計算する（-90度から0度、または0度から180度）。 3. 全オブジェクトの角度の標準偏差を計算する。 4. 標準偏差を90.0で割って正規化する（角度の最大ばらつきが90度の場合）。オブジェクトが1つ以下の場合や角度が全て同じ場合は0.0とする。"
  },
  {
    "id": "line_segment_ratio",
    "name_ja": "直線オブジェクト比率",
    "description": "画像内のオブジェクトが、直線的な線分である割合。",
    "algorithm_idea": "1. 輪郭を検出する。 2. 各輪郭について、cv2.approxPolyDPで近似多角形を計算する（εは輪郭の周長の数%）。 3. 近似多角形の頂点数が2（つまり線分）であるものを直線オブジェクトとみなす。 4. 直線オブジェクトとみなされた輪郭の数を総輪郭数で割り、正規化する。総輪郭数が0の場合は0.0とする。"
  },
  {
    "id": "dominant_hue_of_shapes",
    "name_ja": "図形の主要色相",
    "description": "画像内の主要なオブジェクト（図形）領域における、最も頻繁に出現する色相。",
    "algorithm_idea": "1. 画像から主要な輪郭（オブジェクト）を検出する。 2. 全ての輪郭の内側を塗りつぶしたマスク画像を作成する。 3. 元の画像をHSV色空間に変換する。 4. マスクされた領域のみを対象に、H（色相）チャンネルのヒストグラムを計算する。 5. ヒストグラムのピークとなる色相値を特定する。 6. その色相値を179.0で割って正規化する。オブジェクトがない場合は0.0とする。"
  }
]
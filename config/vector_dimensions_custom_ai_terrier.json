[
  {
    "id": "ear_uprightness_score",
    "name_ja": "耳の立ち上がり度合い",
    "description": "耳の先端と根元を結ぶ線が、頭部に対して垂直に近いほど高い値を示します。ケアーンテリアで高く、ノーフォークテリアで低い傾向があります。",
    "algorithm_idea": "1. 入力画像を`cv2.cvtColor`でグレースケールに変換し、`cv2.equalizeHist`でヒストグラム平坦化を行います。 2. 事前に学習された犬の顔検出器（例: `cv2.CascadeClassifier`でロードしたHaar Cascade分類器）を用いて、顔の領域のバウンディングボックス（`face_x, face_y, face_w, face_h`）を検出します。 3. 顔の検出結果に基づいて、左右の耳を含む可能性のある上部のROI（関心領域）をそれぞれ設定します（例: `top_margin`と`side_margin`を考慮）。 4. 各耳のROIに対し、`cv2.threshold`または`cv2.adaptiveThreshold`で二値化を行い、耳の形状を際立たせます。 5. 二値化された画像に対して、`cv2.findContours`で輪郭検出を実行します。 6. 検出された輪郭の中から、面積や縦横比に基づいて最も耳らしい主要な輪郭（左右の耳）を特定します。例えば、境界ボックスの高さが幅より大きく、かつ顔の上部に位置するものを選択します。 7. 特定された耳の輪郭の最上部Y座標と、耳の根元付近（顔のバウンディングボックス上端のY座標と顔幅の中央X座標から推定）のY座標の差（垂直方向の高さ）を計算します。また、耳の根元から最上部までのユークリッド距離も計算します。 8. `垂直高さ / ユークリッド距離` の比率を計算し、これが耳の立ち上がりスコアとします。この値は0から1の範囲になります。 9. 左右の耳のスコアを平均し、最終的な次元値として出力します。"
  },
  {
    "id": "coat_texture_ruffness",
    "name_ja": "被毛のテクスチャの粗さ",
    "description": "被毛表面の微細な起伏や毛の立ち上がり度合いを示します。値が高いほど毛が粗く、立ち上がっていることを示し、ケアーンテリアで高い傾向があります。",
    "algorithm_idea": "1. 犬の顔検出結果を利用して、顔の周り（頬や首元）や、犬が全身で写っている場合は胴体の一部を、被毛テクスチャ分析用のROIとして設定します。 2. ROIを`cv2.cvtColor`でグレースケールに変換し、`cv2.GaussianBlur`で軽くノイズ除去を行います。 3. グレースケール画像に対し、`cv2.Sobel`フィルタをX方向 (`dx=1, dy=0`) とY方向 (`dx=0, dy=1`) の両方に適用し、各ピクセルにおける勾配マップ（`sobelx`, `sobely`）を得ます。 4. 各ピクセルにおける勾配の大きさを計算します（`magnitude = np.sqrt(sobelx**2 + sobely**2)`）。 5. この勾配の大きさの画像全体の平均値（`np.mean`）を計算します。これがテクスチャの粗さのスコアとなります。 6. 計算されたスコアを、事前に計測された「最も滑らかな毛並みの平均勾配強度」と「最も粗い毛並みの平均勾配強度」の範囲で線形に正規化し、0.0から1.0の範囲にマッピングして出力します。"
  },
  {
    "id": "face_aspect_ratio",
    "name_ja": "顔の縦横比",
    "description": "犬の顔のバウンディングボックスの縦横比（幅/高さ）を示します。値が大きいほど顔が幅広であることを示し、ノーフォークテリアでやや高い傾向があります。",
    "algorithm_idea": "1. 犬の顔検出器（例: `cv2.CascadeClassifier`でロードしたHaar Cascade分類器）を用いて、顔の領域のバウンディングボックス（`face_x, face_y, face_w, face_h`）を検出します。 2. 検出された顔のバウンディングボックスの幅（`face_w`）と高さ（`face_h`）を取得します。 3. 顔の縦横比を `face_w / face_h` として計算します。 4. 計算された値を、想定される顔の縦横比の最小値（例: 0.8）と最大値（例: 1.2）で線形に正規化し、0.0から1.0の範囲にマッピングして出力します（`normalized_value = (value - min_val) / (max_val - min_val)`）。"
  },
  {
    "id": "relative_muzzle_length",
    "name_ja": "マズルの相対的長さ",
    "description": "顔全体の高さに対するマズルの長さの比率を示します。値が小さいほどマズルが短いことを示し、ケアーンテリアでやや低い傾向があります。",
    "algorithm_idea": "1. 犬の顔検出器を用いて、顔の領域のバウンディングボックス（`face_x, face_y, face_w, face_h`）を検出します。 2. 検出された顔のROI内で、鼻検出器（例: `cv2.CascadeClassifier`でロードしたHaar Cascade分類器）を適用し、鼻の領域のバウンディングボックス（`nose_x, nose_y, nose_w, nose_h`）を特定します。 3. 鼻の検出に失敗した場合、または信頼度が低い場合は、顔のバウンディングボックスの中央下部（例: 鼻の中心Y座標を`face_y + face_h * 0.75`、鼻の高さ`face_h * 0.1`程度）を仮の鼻位置とみなすフォールバックロジックを設けます。 4. マズルの長さの近似として、鼻のバウンディングボックスの下端のY座標から顔のバウンディングボックスの下端のY座標までの距離を計算します（`muzzle_length_approx = (face_y + face_h) - (nose_y + nose_h)`）。 5. 顔の高さ（`face_h`）に対するこの近似マズル長の比率（`muzzle_length_ratio = muzzle_length_approx / face_h`）を計算します。 6. 計算された値を、想定されるマズル長比の最小値（例: 0.1）と最大値（例: 0.4）で線形に正規化し、0.0から1.0の範囲にマッピングして出力します。"
  },
  {
    "id": "relative_eye_spacing",
    "name_ja": "目の相対的間隔",
    "description": "顔の幅に対する左右の目の中心間距離の比率を示します。値が大きいほど目が離れていることを示し、ケアーンテリアでやや高い傾向があります。",
    "algorithm_idea": "1. 犬の顔検出器を用いて、顔の領域のバウンディングボックス（`face_x, face_y, face_w, face_h`）を検出します。 2. 特定された顔のROI内で、左右の目検出器（例: `cv2.CascadeClassifier`でロードしたHaar Cascade分類器）をそれぞれ適用し、左右の目の領域のバウンディングボックス（`left_eye_x, ...`, `right_eye_x, ...`）を特定します。 3. 左右の目の検出に失敗した場合、または信頼度が低い場合は、顔のバウンディングボックス内の既定の位置（例: `left_eye_center = (face_x + face_w * 0.3, face_y + face_h * 0.4)`, `right_eye_center = (face_x + face_w * 0.7, face_y + face_h * 0.4)`) を仮の目の中心とするフォールバックロジックを設けます。 4. 左右の目のバウンディングボックスの中心座標を計算します。 5. 左右の目の中心間の水平距離を計算します（`eye_distance = abs(right_eye_center_x - left_eye_center_x)`）。 6. この水平距離を、顔のバウンディングボックスの幅（`face_w`）で割ります（`eye_spacing_ratio = eye_distance / face_w`）。 7. 計算された値を、想定される目の間隔比の最小値（例: 0.3）と最大値（例: 0.6）で線形に正規化し、0.0から1.0の範囲にマッピングして出力します。"
  }
]
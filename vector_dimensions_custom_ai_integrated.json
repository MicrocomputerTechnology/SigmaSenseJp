[
  {
    "id": "main_color_saturation",
    "name_ja": "主要色の彩度",
    "description": "画像内で最も支配的な色の彩度の高さ。",
    "algorithm_idea": "1. 画像をBGRからHSV色空間に変換する。 2. S（彩度）チャンネルのヒストグラムを計算する。 3. 最も頻度の高い彩度の値（ピーク）を求め、255で割って正規化する。",
    "layer": "color"
  },
  {
    "id": "global_luminosity",
    "name_ja": "全体の明るさ",
    "description": "画像全体の平均的な明るさの度合い。",
    "algorithm_idea": "1. 画像をBGRからHSV色空間に変換する。 2. V（Value）チャンネルの画素値の平均を計算する。 3. 結果を255で割って正規化する。",
    "layer": "color"
  },
  {
    "id": "color_diversity_index",
    "name_ja": "色の多様性指数",
    "description": "画像内に含まれる色の種類の多さ。",
    "algorithm_idea": "1. 画像をBGRからLAB色空間に変換する。 2. Lチャンネルは除外し、A*B*チャンネルを結合して2Dヒストグラムを、例えば64x64ビンで計算する。 3. ヒストグラム内の非ゼロビンの数を数える。 4. 非ゼロビンの数を総ビン数（64*64=4096）で割って正規化する。",
    "layer": "color"
  },
  {
    "id": "contrast_level",
    "name_ja": "コントラストレベル",
    "description": "画像全体の明るさの差（コントラスト）の強さ。",
    "algorithm_idea": "1. 画像をグレースケールに変換する。 2. グレースケール画像の画素値の標準偏差を計算する。 3. 結果を128（0-255範囲での最大標準偏差の概算）で割って正規化し、最大値が1を超える場合は1にクリップする。",
    "layer": "context"
  },
  {
    "id": "num_detected_shapes",
    "name_ja": "検出された図形の数",
    "description": "画像内で識別された幾何学的図形の総数。",
    "algorithm_idea": "1. 画像をグレースケールに変換し、ガウシアンブラーを適用する。 2. Cannyエッジ検出を適用する。 3. `cv2.findContours`で輪郭を検出する。 4. 各輪郭の面積が画像の総面積の0.1%以上かつ、周囲長が短いノイズでないものを有効な図形として数える。 5. 検出された図形数を、あらかじめ定めた最大図形数（例：20個）で割って正規化し、1を超える場合は1にクリップする。",
    "layer": "grouping"
  },
  {
    "id": "average_circularity_index",
    "name_ja": "平均円形度",
    "description": "検出された図形が平均してどれだけ円形に近いか。",
    "algorithm_idea": "1. `num_detected_shapes`と同様に有効な輪郭を検出する。 2. 各輪郭について、`cv2.contourArea`と`cv2.arcLength`を使い、円形度 `4 * pi * area / (perimeter^2)` を計算する。 3. 有効な円形度（0.0〜1.0）の平均を計算する。図形がない場合は0.0とする。",
    "layer": "shape"
  },
  {
    "id": "average_rectangularity_index",
    "name_ja": "平均四角形度",
    "description": "検出された図形が平均してどれだけ四角形に近いか。",
    "algorithm_idea": "1. `num_detected_shapes`と同様に有効な輪郭を検出する。 2. 各輪郭について、`cv2.minAreaRect`で最小外接回転矩形を計算し、その幅と高さを得る。 3. `cv2.approxPolyDP`で輪郭を近似し、頂点数が4に近いほど、かつ、矩形のアスペクト比が1に近いほど高いスコアを与える複合的な指標を計算する。 4. これらのスコアの平均を計算し、0.0〜1.0に正規化する。図形がない場合は0.0とする。",
    "layer": "shape"
  },
  {
    "id": "line_segment_density",
    "name_ja": "線分密度",
    "description": "画像内に直線的な線分がどれだけ多く存在するか。",
    "algorithm_idea": "1. 画像をグレースケールに変換し、Cannyエッジ検出を適用する。 2. `cv2.HoughLinesP`で確率的ハフ変換を行い、線分を検出する。 3. 検出された全ての線分の長さの合計を計算する。 4. 合計長さを、画像の対角線の長さと検出された線分の最大期待数（例: 50）を掛け合わせた最大期待値で割って正規化する。",
    "layer": "shape"
  },
  {
    "id": "total_shape_area_ratio",
    "name_ja": "総図形面積比率",
    "description": "検出された図形が画像全体に占める総面積の割合。",
    "algorithm_idea": "1. `num_detected_shapes`と同様に有効な輪郭を検出する。 2. 各輪郭の面積を合計する。 3. 合計面積を画像全体のピクセル数（幅 * 高さ）で割って正規化する。",
    "layer": "grouping"
  },
  {
    "id": "centrality_of_shapes",
    "name_ja": "図形の中央集中度",
    "description": "検出された図形が画像の中心にどれだけ集中しているか。",
    "algorithm_idea": "1. `num_detected_shapes`と同様に有効な輪郭を検出する。 2. 各輪郭の重心（`cv2.moments`から計算）を求める。 3. 画像の中心座標を計算する。 4. 各重心から画像中心までのユークリッド距離の平均を計算する。 5. この平均距離を画像の対角線長の半分で割った値を1から引くことで、中央に近いほど高値となるように正規化する。図形がない場合は0.0とする。",
    "layer": "spatial"
  },
  {
    "id": "vertical_balance_score",
    "name_ja": "垂直方向のバランススコア",
    "description": "図形が垂直方向（上下）にどれだけ均等に配置されているか。",
    "algorithm_idea": "1. `num_detected_shapes`と同様に有効な輪郭を検出する。 2. 各輪郭の重心のY座標を収集する。 3. Y座標の平均が画像高さの中央 (H/2) からどれだけ離れているかを計算する。 4. `1 - (abs(average_Y - H/2) / (H/2))` で正規化する。図形がない場合は0.0とする。",
    "layer": "spatial"
  },
  {
    "id": "horizontal_balance_score",
    "name_ja": "水平方向のバランススコア",
    "description": "図形が水平方向（左右）にどれだけ均等に配置されているか。",
    "algorithm_idea": "1. `num_detected_shapes`と同様に有効な輪郭を検出する。 2. 各輪郭の重心のX座標を収集する。 3. X座標の平均が画像幅の中央 (W/2) からどれだけ離れているかを計算する。 4. `1 - (abs(average_X - W/2) / (W/2))` で正規化する。図形がない場合は0.0とする。",
    "layer": "spatial"
  },
  {
    "id": "overlap_degree",
    "name_ja": "重なり度",
    "description": "検出された複数の図形が互いに重なり合っている領域の割合。",
    "algorithm_idea": "1. `num_detected_shapes`と同様に有効な輪郭を検出する。 2. 全ての輪郭を個別のバイナリマスクとして同じサイズのゼロ配列（画像サイズ）に描画し、重ね合わせる。 3. 複数のマスクが重なっているピクセル（画素値が1を超えるピクセル）の数を数える。 4. 重なっているピクセル数を、全図形の総面積で割って正規化する。総面積が0の場合は0.0とする。",
    "layer": "grouping"
  },
  {
    "id": "mean_color_saturation_of_shapes",
    "name_ja": "図形の平均彩度",
    "description": "検出された各図形領域内のピクセルの平均彩度。",
    "algorithm_idea": "1. `num_detected_shapes`と同様に有効な輪郭を検出する。 2. 各輪郭について、その内部のピクセルのみを抽出し、それらをBGRからHSV色空間に変換する。 3. 抽出されたピクセル群のS（彩度）チャンネルの平均値を計算する。 4. 全ての輪郭について計算された平均彩度をさらに平均し、255で割って正規化する。図形がない場合は0.0とする。",
    "layer": "color"
  },
  {
    "id": "dominant_hue_of_shapes",
    "name_ja": "図形の主要色相",
    "description": "検出された図形が持つ最も支配的な色相。",
    "algorithm_idea": "1. `num_detected_shapes`と同様に有効な輪郭を検出する。 2. 全ての輪郭内部のピクセルを集め、BGRからHSV色空間に変換する。 3. H（色相）チャンネルのヒストグラムを計算する。 4. ヒストグラムのピーク（最頻値）を求め、179（HUEの最大値）で割って正規化する。図形がない場合は0.0とする。",
    "layer": "color"
  },
  {
    "id": "aspect_ratio_consistency",
    "name_ja": "アスペクト比の一貫性",
    "description": "複数の図形がある場合に、それらのアスペクト比がどれだけ似ているか。",
    "algorithm_idea": "1. `num_detected_shapes`と同様に有効な輪郭を検出する。 2. 各輪郭について、`cv2.minAreaRect`で最小外接回転矩形を計算し、その幅と高さからアスペクト比（幅/高さ、または高さ/幅のうち大きい方）を計算する。 3. 計算された全てのアスペクト比の標準偏差を求める。 4. 標準偏差を、例えば5.0（典型的な最大アスペクト比の差）で割った値を1から引くことで、一貫性が高いほど高値となるように正規化する。図形が1つ以下の場合やアスペクト比が計算できない場合は1.0とする。",
    "layer": "shape"
  },
  {
    "id": "density_of_small_shapes",
    "name_ja": "小図形の密度",
    "description": "画像内に占める比較的小さな図形の数の割合。",
    "algorithm_idea": "1. `num_detected_shapes`と同様に有効な輪郭を検出する。 2. 各輪郭の面積が画像の総面積の0.5%以下であるものを「小さな図形」として数える。 3. 小さな図形の数を、検出された総図形数で割って正規化する。総図形数が0の場合は0.0とする。",
    "layer": "grouping"
  },
  {
    "id": "average_convexity_index",
    "name_ja": "平均凸性指数",
    "description": "検出された図形が平均してどれだけ凸形状に近いか。",
    "algorithm_idea": "1. `num_detected_shapes`と同様に有効な輪郭を検出する。 2. 各輪郭について、`cv2.convexHull`で凸包を計算し、`cv2.contourArea`で輪郭の面積とその凸包の面積を求める。 3. 凸性 `(輪郭面積 / 凸包面積)` を計算する（凸包面積が0の場合は1.0とする）。 4. これらの凸性の平均を計算する。図形がない場合は0.0とする。",
    "layer": "shape"
  },
  {
    "id": "contour_roughness_score",
    "name_ja": "輪郭の粗さスコア",
    "description": "検出された図形の輪郭が平均してどれだけギザギザしているか。",
    "algorithm_idea": "1. `num_detected_shapes`と同様に有効な輪郭を検出する。 2. 各輪郭について、`cv2.arcLength`で元の輪郭の周囲長を計算し、`cv2.approxPolyDP`で近似多角形を生成しその周囲長も計算する。 3. `(元の周囲長 - 近似多角形の周囲長) / 元の周囲長` を計算し、これを「粗さ」の指標とする（元の周囲長が0の場合は0.0）。値が負になる場合は0.0にクリップ。 4. 全ての輪郭の「粗さ」指標の平均を計算し、0.0から1.0に正規化する。粗さが大きいほど値が高いように調整。図形がない場合は0.0とする。",
    "layer": "shape"
  },
  {
    "id": "alignment_strength",
    "name_ja": "整列の強さ",
    "description": "検出された図形が水平または垂直方向にどれだけ規則的に整列しているか。",
    "algorithm_idea": "1. `num_detected_shapes`と同様に有効な輪郭を検出する。 2. 各輪郭の重心のX座標とY座標を収集する。 3. X座標の標準偏差 `std_x` とY座標の標準偏差 `std_y` を計算する。 4. `alignment_score = 1 - (std_x / (image_width / 2) + std_y / (image_height / 2)) / 2` で計算し、0.0から1.0に正規化する（画像中央に集まるほど、または完全に水平・垂直に並ぶほど標準偏差は小さくなる）。負の値は0.0にクリップ。図形が1つ以下の場合や標準偏差が計算できない場合は1.0とする。",
    "layer": "spatial"
  },
  {
    "id": "dominant_line_angle",
    "name_ja": "主要な線の角度",
    "description": "画像内で検出された線分の主要な角度。0度は水平、90度は垂直を示す。",
    "algorithm_idea": "1. HoughLinesPで線分を検出する。 2. 各線分の角度をatan2で計算する。 3. 角度のヒストグラムを作成し、最も頻度の高い角度（ピーク）を主要な角度とする。 4. 角度を180で割って正規化する（0-1の範囲）。",
    "layer": "shape"
  },
  {
    "id": "contour_fluctuation",
    "name_ja": "輪郭の揺らぎ",
    "description": "動物の輪郭線の微細な揺らぎや複雑さ。毛並み、羽毛、不定形な体表の質感など、柔らかな印象を与える要素を捉えます。",
    "algorithm_idea": "1. 画像をグレースケールに変換し、適応的閾値処理などで前景と背景を分離し二値化する。 2. 二値化された画像から`cv2.findContours`を用いて輪郭線を検出する。 3. 検出された輪郭の中から、面積が最も大きい（または画像の大部分を占める）主要な輪郭線を選択する。 4. 選択された輪郭線の点の集合に対して、`cv2.convexHull`を計算し、その凸包の周囲長を求める。 5. 輪郭線自身の実際の長さ（`cv2.arcLength`）と、凸包の周囲長の比率を計算する（`contour_length / convex_hull_perimeter`）。比率が大きいほど、輪郭線が凸包から離れており、揺らぎが大きいと判断できる。 6. 計算された比率を0.0から1.0の範囲に線形正規化する（例：理論上の最小値1.0（完全な凸形状）から観測される最大値までの範囲でスケーリング）。",
    "layer": "lyra"
  },
  {
    "id": "edge_softness",
    "name_ja": "エッジの柔らかさ",
    "description": "物体の輪郭や内部の線がどれだけ滑らかで、境界が曖昧であるか。シャープな対比の少なさや、光の回り込みによる柔らかな印象を捉えます。",
    "algorithm_idea": "1. 画像をグレースケールに変換する。 2. `cv2.Laplacian`フィルタを適用し、局所的な輝度変化の二階微分を計算する。このフィルタはエッジの強度に敏感に反応する。 3. `Laplacian`フィルタの出力画像の絶対値を取り、そのピクセル値の平均または分散を計算する。この値が小さいほど、画像全体のエッジが少なく、あるいはエッジのコントラストが低い（＝柔らかい）と判断できる。 4. 計算された平均または分散値の逆数（または適度なスケーリングと反転）をとり、0.0から1.0の範囲に正規化する（値が小さいほど柔らかさが高い）。",
    "layer": "lyra"
  },
  {
    "id": "motion_impression",
    "name_ja": "動きの余韻",
    "description": "静止画から感じられる動きの残像や、しなやかなポーズによって示唆される運動性。ブレや流れるような身体の線を捉えます。",
    "algorithm_idea": "1. 画像をグレースケールに変換する。 2. `cv2.Sobel`フィルタを適用し、X方向とY方向の勾配強度を計算し、`cv2.cartToPolar`を用いて各ピクセルにおける勾配の方向（角度）を算出する。 3. 計算された勾配方向のヒストグラムを作成する。 4. ヒストグラムの各ビンの分布の集中度を評価する。例えば、ヒストグラムの最大値と平均値の比や、エントロピーを計算する。特定の方向に勾配が強く集中している場合（ヒストグラムのピークが鋭い場合）、ブレや動きの方向性が強いと判断できる。 5. 集中度が高いほど動きの余韻が強いとみなし、計算された値を0.0から1.0の範囲に正規化する（エントロピーを使う場合は、エントロピーの逆数をとるか、1から引くなどで変換）。",
    "layer": "lyra"
  },
  {
    "id": "gaze_intensity",
    "name_ja": "視線の強度",
    "description": "動物の目から感じられる感情や意図。瞳の輝き、視線の方向性、目のコントラストなど、視線が持つ存在感を捉えます。",
    "algorithm_idea": "1. 画像をグレースケールに変換する。 2. Haar Cascade分類器やより高性能な深度学習モデル（例: OpenCVのDNNモジュールで顔・目検出モデルを利用）を用いて、画像内の目の領域を検出する。 3. 検出された各目の領域に対して、`cv2.createCLAHE`などの適応的ヒストグラム平坦化を適用し、局所的なコントラストを強調する。 4. 強調された目の領域内で、輝度値の標準偏差を計算する。また、瞳孔内の反射光（ハイライト）の領域（高輝度ピクセルのクラスタ）の数や面積を検出する。 5. 高いコントラストと明確なハイライト（輝度標準偏差が高く、明るいクラスタが多い）があるほど、視線の強度が高いと判断できる。検出された複数の目がある場合は平均値を取り、計算された値を0.0から1.0の範囲に正規化する。",
    "layer": "lyra"
  },
  {
    "id": "texture_irregularity",
    "name_ja": "テクスチャの不均一性",
    "description": "動物の体表の模様や毛並み、羽毛などのテクスチャが持つ、密度の不均一性やランダムな配置。自然な質感を捉えます。",
    "algorithm_idea": "1. 画像をグレースケールに変換し、輝度値を0-255の範囲で正規化する。 2. `skimage.feature.graycomatrix`（scikit-imageライブラリを使用）を用いて、GLCM（Gray-Level Co-occurrence Matrix）を計算する。複数の方向（0, 45, 90, 135度）と距離（例：1ピクセル）でGLCMを計算し、それらを平均化する。 3. 平均化されたGLCMから、`skimage.feature.graycoprops`を用いてエントロピーやコントラストなどの統計的特徴量を抽出する。 4. エントロピーはテクスチャのランダム性や不均一性を直接的に示す指標となる。エントロピー値が大きいほど、不均一性が高いと判断できる。 5. 計算されたエントロピー値を0.0から1.0の範囲に正規化する（例：理論上の最小値0から最大値までの範囲で線形スケーリング）。",
    "layer": "lyra"
  },
  {
    "id": "volume_roundness",
    "name_ja": "体積の丸み",
    "description": "動物の体躯や部位が持つ、柔らかく丸みを帯びた印象。角張った部分が少なく、全体的にふっくらとした立体感を捉えます。",
    "algorithm_idea": "1. 画像をグレースケールに変換し、適応的閾値処理や前景抽出（GrabCutなど）で前景（動物）を二値化する。 2. 二値化された前景領域に対して、`cv2.distanceTransform`を適用し、各前景ピクセルから最も近い背景ピクセルまでのユークリッド距離を計算する。これにより、物体の内部からの距離マップが生成される。 3. 距離変換マップの最大値（物体の最も中心に近い部分の半径に相当）と、前景領域のピクセル数（面積）を計算する。 4. 体積の丸みは、距離マップの最大値が、前景領域の面積から計算される理想的な円の半径（`sqrt(foreground_area / pi)`）に対してどれだけ大きいかで評価できる。例えば、`max_distance / sqrt(foreground_area / pi)` のような比率。値が大きいほど、物体が中心に集積し、丸みを帯びていると判断できる。 5. 計算された比率を0.0から1.0の範囲に線形正規化する。",
    "layer": "lyra"
  },
  {
    "id": "light_envelopment",
    "name_ja": "光の包み込み感",
    "description": "光が動物の体に柔らかく当たり、影が滑らかなグラデーションを形成している印象。奥行きと安心感をもたらす照明効果を捉えます。",
    "algorithm_idea": "1. 画像をHSV色空間に変換し、V（明度）チャネルを抽出する。 2. Vチャネルの輝度ヒストグラムを計算する（`cv2.calcHist`）。 3. ヒストグラムのピークの鋭さ（シャープネス）を評価する。例えば、ヒストグラムの最大値と平均値の比や、ヒストグラムの分散の逆数。輝度変化が滑らかであるほど、ヒストグラムは平坦で広がりを持ち、ピークが鋭くない。 4. 輝度ヒストグラムのピークが鋭くないほど（つまり、輝度の階調が豊かで滑らかなグラデーションが多いほど）、光が包み込んでいる印象が強いと判断できる。 5. 計算されたピークの鋭さの逆数（または1から正規化されたピーク鋭度を引くなど）を0.0から1.0の範囲に正規化する（ピークが鈍いほど高い値）。",
    "layer": "lyra"
  },
  {
    "id": "color_warmth_coolness",
    "name_ja": "色彩の暖かさ・冷たさ",
    "description": "画像全体の色彩が持つ、暖かさ（赤、オレンジ系）や冷たさ（青、緑系）といった感情的な印象。動物の毛色や周囲の環境色から感じられる情緒を捉えます。",
    "algorithm_idea": "1. 画像をHSV色空間に変換する。 2. H（色相）チャネルのピクセル値を抽出し、前景領域（動物）のピクセルのみに限定する。 3. 抽出されたH値の平均を計算する。OpenCVにおけるHの値は0〜179で、赤系が0〜約15と約165〜179、黄系が約15〜45、緑系が約45〜90、青系が約90〜120、紫系が約120〜165となる。 4. この平均H値に基づいて、暖かさ・冷たさを評価する。例えば、平均Hが赤・オレンジに近いほど暖かく、青・シアンに近いほど冷たいと判断できる。これを-1.0（非常に冷たい）から1.0（非常に暖かい）の範囲にマッピングするカスタム関数を設計する（例：`f(H) = cos(H * pi / 90)`など）。 5. 最終的に、計算された値を`(-1.0, 1.0)`の範囲から` (0.0, 1.0)`の範囲に線形正規化する（例：`(val + 1.0) / 2.0`）。",
    "layer": "lyra"
  },
  {
    "id": "vetra_symmetry_score",
    "name_ja": "[Vetra発見] symmetry_score",
    "description": "Measures symmetry based on Hu Moments.",
    "algorithm_idea": "...",
    "layer": "vetra_discovered"
  },
  {
    "id": "vetra_edge_density",
    "name_ja": "[Vetra発見] edge_density",
    "description": "Calculates the density of edges.",
    "algorithm_idea": "...",
    "layer": "vetra_discovered"
  },
  {
    "id": "vetra_gaze_curvature",
    "name_ja": "[Vetra発見] gaze_curvature",
    "description": "Approximates the curvature of a dominant line.",
    "algorithm_idea": "...",
    "layer": "vetra_discovered"
  },
  {
    "id": "vetra_texture_complexity",
    "name_ja": "[Vetra発見] texture_complexity",
    "description": "Measures the complexity of surface texture.",
    "algorithm_idea": "self._calculate_texture_complexity(image)",
    "layer": "vetra_discovered"
  }
]